Harnessing a Simple Program
---------------------------

In this quick tutorial you will be guided through the steps to harness a very
simple snippet of binary code. Here it is, weighing in at only two lines of x86
assembly.

.. literalinclude:: ../../tests/square/square.amd64.s
  :language: NASM

This example can be found in the ``tests`` directory of the repository, in the
file ``square.amd64.s``. There are a number of other small assembly examples there
along with it. There is also a ``Makefile`` in that directory and you will have
to run ``make`` there in order to generate the binary code used in this and
other tutorials involving those tests. Once you have run ``make``, the
corresponding binary, which we will analyze in this tutorial, will be in the
file ``square.amd64.bin``.

A reasonable first step in harnessing is to run SmallWorld's basic harness
script which assumes nothing about the code: ``basic_harness.py`` (which also
lives in the ``examples`` directory). That script is fairly simple, so let's have
a look at it.

.. literalinclude:: ../../examples/basic_harness.py
  :language: Python

After the imports, the script sets up logging and hinting. Logging is probably
self-explanatory (change level to ``logging.DEBUG`` to get lots of low-level
output). **Hinting** is a SmallWorld concept. Hints are described in detail in
:ref:`hinting` but the basic idea is that SmallWorld includes various
**analyses** that are intended to provide hints that can guide the creation of
a code harness. You can read more about analyses in :ref:`analyses`.

Next in the script, a cpu state is created. This is another SmallWorld concept
described in :ref:`state` in detail. You can think of it as a place to set up
registers and memory (which have convenient stack and heap abstractions) with
specific values in a way that is agnostic to details about any particular
dynamic analysis employing a specific emulator or engine. So, the same
``state`` could be applied to a Unicorn emulator or a angr engine or ...

In the script, we employ an **initializer** to zero out all the registers in
the state and then load the binary code from a file and map it into the state.

Finally, the script runs various analyses on the code and cpu state in order to
help explicate how it might be better harnessed. This is the last line in the
script ``smallworld.analyze(state)`` and it is what will generate hints.

Note that all of this setup performed is entirely generic; this script assumes
nothing about the binary to be harnessed. To run the script we just put the
binary at the end of the commandline ``python3 basic_harnesss.py square.amd64.bin``.

Here is what that outputs

.. command-output:: python3 examples/basic_harness.py tests/square/square.amd64.bin
    :cwd: ../../

We get back one hint per attempt at executing ``square.amd64.bin``.  The hint is
generated by an analysis called ``input_colorizer`` which attempts to determine
what registers and instructions are using input values by setting them to
random values and then observing when those values are used by instructions.
This is an ``InputUseHint`` and if we know how to interpret it, it tells us
that the register ``edi`` is an input to this snippet of code and should really
be set explicitly. We can now create a new script ``square.amd64.py`` which harnesses
``square.amd64.bin`` perfectly.
		    
.. literalinclude:: ../../tests/square/square.amd64.py
  :language: Python

To the ``basic_harness.py`` we have added a line to set the initial value of
``edi`` via the commandline, a new line which simply emulates, and a final line
to read out the result which is in the register ``eax``.

Here is what running that new harness looks like

.. command-output:: python3 square.amd64.py 42
    :cwd: ../../tests/square/

Since ``42*42=1764`` which is ``0x6e4`` we have harnessed
``square.amd64.bin`` completely.
