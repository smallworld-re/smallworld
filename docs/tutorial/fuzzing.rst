.. _fuzzing:

Fuzzing
=======

Introduction
------------
In this tutorial you will be guided through building a simple fuzzing harness
and fuzzing it with `AFL++`_. It assumes you are already familiar with building a SmallWorld
harness and with `AFL++`_. For this tutorial we will be using a very simple binary that reads
four bytes (which we're going to pretend is a size) and exits if they are 11 or less, then reads 
the next four bytes and compares them one-by-one to the values 98, 97, 100, and 33 exiting if 
they are not equal. If it makes it through all of the compares it crashes by writing to an 
unmapped address.

.. literalinclude:: ../../tests/fuzz/fuzz.amd64.s
  :language: NASM

.. _AFL++: https://aflplus.plus/

The source for this example can be found in the ``tests/fuzz`` directory of the
repository in the file ``fuzz.amd64.s``. This file can be assembled with ``nasm``
with the command ``nasm fuzz.amd64.bin -o fuzz.amd64.bin``.

Building Our Harness
--------------------

Now we need to build a SmallWorld harness for this code. First, we begin be
initializing the machine, platform, cpu, and code. This is done in the same way
as any other SmallWorld harness.

.. literalinclude:: ../../tests/fuzz/afl_fuzz.amd64.py
  :language: python
  :lines: 10-18

Next, we need somewhere for our input to live. We're going to use a heap to make
things easy. After we create the heap, we're going to put some example input on
it.

.. literalinclude:: ../../tests/fuzz/afl_fuzz.amd64.py
  :language: python
  :lines: 18-24

Then we need to set our registers and add everthing to our machine. We set `rip`
to `0x1000` (where we mapped the code) and `rdi` to point to our input.

.. literalinclude:: ../../tests/fuzz/afl_fuzz.amd64.py
  :language: python
  :lines: 25-31

Now for the part where most of the work happens. `AFL++`_ is going to generate an input
and hand it to our harness. However, that input is just a series of bytes. We need to
apply that input to our machine. In order to do that we define a callback function. 
The parameters to this callback are specified in the `AFL++`_ documentation for
`Unicorn mode`_. Briefly, the `uc` is a `Unicorn emulator object`_ which you can use to
write the input to memory or registers and `input` is the input generated by `AFL++`_ as
a Python `bytes`. If the input given by `AFL++`_ won't work for your case then you can
return `False` to skip it. 

For our example we will check to make sure the input isn't bigger than our heap and then
just write it to the address of our input.

.. _Unicorn emulator object: https://www.unicorn-engine.org/docs/tutorial.html
.. _Unicorn mode: https://github.com/AFLplusplus/AFLplusplus/blob/stable/unicorn_mode/README.md

.. literalinclude:: ../../tests/fuzz/afl_fuzz.amd64.py
  :language: python
  :lines: 33-37

All that's left is to start our emulation. SmallWorld only supports fuzzing with our
`UnicornEmulator`. The only other difference that we end with `machine.fuzz()` and pass
in out input callback.

.. literalinclude:: ../../tests/fuzz/afl_fuzz.amd64.py
  :language: python
  :lines: 39-

And that's it. If we put it all together, we have:

.. literalinclude:: ../../tests/fuzz/afl_fuzz.amd64.py
  :language: python

Running With AFL++
------------------
To run our harness with `AFL++`_ using a command such as the following:

.. code-block:: bash
  
  afl-fuzz -t 10000 -U -m none -i inputs -o outputs -- python3 our_fuzz_harness.py @@


and you should see a TUI that looks like this:

.. literalinclude:: ./afl_output.txt
  :language: none

See the `AFL++`_ documentation for a more complete listing to all of the arguments and options.

Breakdown of an Input
---------------------
Now, lets look at an input the crashed our program. Using `xxd` we have the following::
  
  00000000: ff7f 0000 6261 6421                      ....bad!

As you can see, the first four bytes `ff7f 0000` are an integer greater than 11. Then we have
the bytes `0x62` (98), `0x61` (97), `0x64` (100), and `0x21` (33) which spells `bad!` in ascii.
Note that this input matches what was required as discussed in the introduction of this tutorial.

Next Steps
----------
If you are interested in a more in depth tutorial on using SmallWorld for vulnerability
research (including fuzzing), then checkout our in depth tutorial on using SmallWorld to
analyize an RTOS found in the repo under `use_cases/rtos_demo`.

